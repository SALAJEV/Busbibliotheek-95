<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Busbibliotheek voor bussen van De Lijn: zoek een voertuig en volg het live.">
<meta name="theme-color" content="#f4f7fb">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Busbibliotheek">
<link rel="apple-touch-icon" href="media/logo_light.png">
<link rel="manifest" href="manifest.json">
<title>Busbibliotheek</title>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

<link rel="stylesheet" href="style.css?v=20260218-3">
</head>
<body>
<div id="splash" role="img" aria-label="Busbibliotheek laden">
  <picture class="logo">
    <source media="(prefers-color-scheme: light)" srcset="media/logo_light.png">
    <source media="(prefers-color-scheme: dark)" srcset="media/logo_dark.png">
    <img src="media/logo_light.png" alt="Busbibliotheek">
  </picture>
  <p class="splash-credit">Made by @delijn_busspotter</p>
</div>
<div class="container">
  <div class="header-bar">
    <div class="header-intro">
      <h1 id="appTitle">Busbibliotheek</h1>
      <p id="appSubtitle">Zoek een voertuig en volg het in realtime.</p>
      <p id="appContextLine" class="app-context-line">Over bussen van de Vlaamse vervoermaatschappij De Lijn.</p>
    </div>
    <div class="header-actions">
      <button id="installBtn" title="App installeren op thuisscherm">Installeer App</button>
      <div class="favorites-top">
        <button id="favoritesToggleBtn" class="icon-btn favorites-toggle-btn" type="button" title="Favorieten" aria-label="Favorieten" aria-controls="favoritesPanel" aria-expanded="false">&#9734;</button>
        <div id="favoritesPanel" class="favorites-panel" hidden>
          <h3 id="favoritesTitle">Favorieten</h3>
          <div id="favoritesList" class="chip-row"></div>
        </div>
      </div>
      <button id="settingsToggleBtn" class="icon-btn" type="button" title="Instellingen" aria-label="Instellingen" aria-controls="settingsPanel" aria-expanded="false">&#9881;</button>
    </div>
  </div>
  <div id="iosInstallHint" class="hint" hidden></div>

  <div class="search-row">
    <input id="voertuignummer" placeholder="Voertuignummer of nummerplaat" 
           oninput="toonSuggesties()" 
           onkeydown="if(event.key==='Enter'){zoekAlles();}" autocomplete="off">
    <button id="searchBtn" type="button" title="Zoeken" aria-label="Zoeken" onclick="zoekAlles()"><span class="search-btn-icon" aria-hidden="true">&#128269;</span></button>
  </div>
  <ul id="suggestielijst"></ul>

  <div class="results-wrap">
    <button class="close-btn" id="closeBtn" onclick="terug()" title="Venster sluiten" aria-label="Sluiten">&times;</button>
    <div class="grid" id="resultsGrid">
      <div class="card">
        <h2 id="staticCardTitle">Voertuiginformatie</h2>
        <div id="vasteData">Geen voertuig geselecteerd.</div>
      </div>

      <div class="card">
        <h2 id="realtimeCardTitle">Realtimegegevens</h2>
        <div id="realtime" class="loading">Geen gegevens beschikbaar.</div>
        <div id="map"></div>
        <div id="lastUpdate" hidden>Laatste update: -</div>
      </div>
    </div>
  </div>

  <footer>
    <h3 id="disclaimerTitle">Disclaimer</h3>
    <p id="disclaimerText">De informatie op deze website wordt verstrekt zonder garanties. Busbibliotheek is niet aansprakelijk voor vertragingen, fouten of onnauwkeurigheden in realtimegegevens. Gebruik op eigen risico. Raadpleeg voor officiele ritinformatie de bevoegde vervoersmaatschappij.</p>
  </footer>

</div>

<div id="settingsBackdrop" class="settings-backdrop"></div>
<aside id="settingsPanel" class="settings-panel" aria-hidden="true" inert>
  <div class="settings-panel-header">
    <h3 id="settingsTitle">Instellingen</h3>
    <button id="settingsCloseBtn" class="settings-close-btn" type="button" title="Sluit instellingen" aria-label="Sluit instellingen">&times;</button>
  </div>
  <div class="settings-grid">
    <div>
      <label for="intervalSelect" id="intervalLabel">Update-interval</label>
      <select id="intervalSelect">
        <option value="10000" selected id="intervalOpt10">10 seconden</option>
        <option value="15000" id="intervalOpt15">15 seconden</option>
        <option value="30000" id="intervalOpt30">30 seconden</option>
      </select>
    </div>
    <div>
      <label for="themeSelect" id="themeLabel">Thema</label>
      <select id="themeSelect">
        <option value="auto" id="themeAutoOpt">Automatisch</option>
        <option value="light" id="themeLightOpt">Licht</option>
        <option value="dark" id="themeDarkOpt">Donker</option>
      </select>
    </div>
    <div>
      <label for="colorThemeSelect" id="colorThemeLabel">Kleurthema</label>
      <select id="colorThemeSelect">
        <option value="classic" id="colorClassicOpt" selected>Klassiek (zwart-wit)</option>
        <option value="blue" id="colorBlueOpt">Blauw</option>
        <option value="green" id="colorGreenOpt">Groen</option>
        <option value="yellow" id="colorYellowOpt">Geel</option>
        <option value="red" id="colorRedOpt">Rood</option>
      </select>
    </div>
    <div>
      <label for="languageSelect" id="languageLabel">Taal</label>
      <select id="languageSelect">
        <option value="nl">Nederlands</option>
        <option value="fr">Fran&ccedil;ais</option>
        <option value="en">English</option>
        <option value="de">Deutsch</option>
        <option value="pl">Polski</option>
        <option value="es">Espa&ntilde;ol</option>
        <option value="ru">&#1056;&#1091;&#1089;&#1089;&#1082;&#1080;&#1081;</option>
      </select>
    </div>
  </div>
  <p id="feedStatus" class="settings-feed-status" hidden></p>
</aside>

<div id="funnyModal" class="funny-modal" hidden role="dialog" aria-modal="true" aria-labelledby="funnyModalTitle">
  <div class="funny-modal-card">
    <h3 id="funnyModalTitle">Buswijsheid</h3>
    <p>De beste bussen komen van Mercedes-Benz.</p>
    <button id="funnyModalCloseBtn" type="button">Haha, oke</button>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="translations.js?v=20260218-1"></script>
<script>
// Splash controls (mobile-first startup experience)
const splash = document.getElementById("splash");
function hideSplash(ms = 260) {
  const s = splash;
  if (!s || s.dataset.hiding === "1") return;
  s.dataset.hiding = "1";
  s.classList.add("hidden");
  const cleanup = () => {
    if (s.parentNode) s.parentNode.removeChild(s);
  };
  s.addEventListener("transitionend", cleanup, { once: true });
  setTimeout(cleanup, ms + 120);
}
window.addEventListener('load', () => setTimeout(hideSplash, 520));
splash?.addEventListener('click', () => hideSplash(150));
document.addEventListener('touchstart', () => hideSplash(150), { once: true });

// Install Prompt (beter gecontroleerde PWA-installatie)
let deferredPrompt = null;
const installBtn = document.getElementById('installBtn');
const iosInstallHintEl = document.getElementById("iosInstallHint");
const settingsPanelEl = document.getElementById("settingsPanel");
const settingsBackdropEl = document.getElementById("settingsBackdrop");
const settingsToggleBtn = document.getElementById("settingsToggleBtn");
const settingsCloseBtn = document.getElementById("settingsCloseBtn");
const favoritesToggleBtn = document.getElementById("favoritesToggleBtn");
const favoritesPanelEl = document.getElementById("favoritesPanel");
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.classList.add('show');
});
installBtn.addEventListener('click', async () => {
  if (deferredPrompt) {
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`Gebruiker antwoord: ${outcome}`);
    deferredPrompt = null;
    installBtn.classList.remove('show');
  } else if (isIosInstallable()) {
    iosInstallHintEl.hidden = false;
  }
});
window.addEventListener('appinstalled', () => {
  console.log('App succesvol geinstalleerd');
  installBtn.classList.remove('show');
  iosInstallHintEl.hidden = true;
  deferredPrompt = null;
});

// Constants
const BASE_URL = "https://pub-611b5bc156eb455ba86d9bcece9aea1c.r2.dev";
const API_URL = "https://busbibliotheek95.pages.dev/api";
const FAVORITES_KEY = "bb_favorites_v1";
const SETTINGS_KEY = "bb_settings_v1";
let updateIntervalMs = 10000;

const voertuigInput = document.getElementById("voertuignummer");
const suggestieLijst = document.getElementById("suggestielijst");
const realtimeEl = document.getElementById("realtime");
const vasteDataEl = document.getElementById("vasteData");
const resultsWrapEl = document.querySelector(".results-wrap");
const resultsGridEl = document.getElementById("resultsGrid");
const closeBtnEl = document.getElementById("closeBtn");
const mapEl = document.getElementById("map");
const searchBtn = document.getElementById("searchBtn");
const favoritesListEl = document.getElementById("favoritesList");
const intervalSelect = document.getElementById("intervalSelect");
const themeSelect = document.getElementById("themeSelect");
const colorThemeSelect = document.getElementById("colorThemeSelect");
const languageSelect = document.getElementById("languageSelect");
const intervalOpt10El = document.getElementById("intervalOpt10");
const intervalOpt15El = document.getElementById("intervalOpt15");
const intervalOpt30El = document.getElementById("intervalOpt30");
const themeAutoOptEl = document.getElementById("themeAutoOpt");
const themeLightOptEl = document.getElementById("themeLightOpt");
const themeDarkOptEl = document.getElementById("themeDarkOpt");
const colorThemeLabelEl = document.getElementById("colorThemeLabel");
const colorClassicOptEl = document.getElementById("colorClassicOpt");
const colorBlueOptEl = document.getElementById("colorBlueOpt");
const colorGreenOptEl = document.getElementById("colorGreenOpt");
const colorYellowOptEl = document.getElementById("colorYellowOpt");
const colorRedOptEl = document.getElementById("colorRedOpt");
const themeColorMetaEls = Array.from(document.querySelectorAll('meta[name="theme-color"]'));
const prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
const lastUpdateEl = document.getElementById("lastUpdate");
const appTitleEl = document.getElementById("appTitle");
const appSubtitleEl = document.getElementById("appSubtitle");
const appContextLineEl = document.getElementById("appContextLine");
const favoritesTitleEl = document.getElementById("favoritesTitle");
const settingsTitleEl = document.getElementById("settingsTitle");
const intervalLabelEl = document.getElementById("intervalLabel");
const themeLabelEl = document.getElementById("themeLabel");
const languageLabelEl = document.getElementById("languageLabel");
const staticCardTitleEl = document.getElementById("staticCardTitle");
const realtimeCardTitleEl = document.getElementById("realtimeCardTitle");
const disclaimerTitleEl = document.getElementById("disclaimerTitle");
const disclaimerTextEl = document.getElementById("disclaimerText");
const feedStatusEl = document.getElementById("feedStatus");
const funnyModalEl = document.getElementById("funnyModal");
const funnyModalCloseBtn = document.getElementById("funnyModalCloseBtn");

let voertuigen = [];
let trips = [];
let routes = [];
let stops = [];
const stopsById = new Map();
const tripsById = new Map();
const routesById = new Map();
const routesByKey = new Map();
let map, marker, refresh;
let trailLine = null;
let routeTrail = [];
let delayMinutes = 0;
let currentVehicleId = "";
let favorites = [];
let settingsOpen = false;
let favoritesPanelOpen = false;
let feedEndDateValue = "";
let vehiclePlateFieldKey = "";
let oldVehicleNumbersFieldKey = "";
let oldLicensePlatesFieldKey = "";
const INACTIVITY_LIMIT_MS = 5 * 60 * 1000;
const INACTIVITY_CHECK_MS = 15000;
let lastUserInteractionAt = Date.now();
let realtimePausedByInactivity = false;
let inactivityCheckHandle = null;
let settings = {
  intervalMs: 10000,
  theme: "auto",
  colorTheme: "classic",
  language: "nl"
};

const translationsConfig = window.BB_TRANSLATIONS || {};
const i18n = translationsConfig.i18n || { nl: {} };
const localWordLabels = translationsConfig.localWordLabels || {};
const vehicleFieldLabels = translationsConfig.vehicleFieldLabels || {};
const localeMap = translationsConfig.localeMap || { nl: "nl-NL" };
const delayLexicon = translationsConfig.delayLexicon || {};

const DEFAULT_LANG = "nl";
const FALLBACK_LANG = "en";
const ALLOWED_COLOR_THEMES = ["classic", "blue", "green", "yellow", "red"];
const ALLOWED_UPDATE_INTERVALS = [10000, 15000, 30000];
const REQUEST_TIMEOUT_MS = 12000;

function normalizeUpdateIntervalMs(intervalMs) {
  const value = Number(intervalMs);
  return ALLOWED_UPDATE_INTERVALS.includes(value) ? value : 10000;
}

async function fetchWithTimeout(url, options = {}, timeoutMs = REQUEST_TIMEOUT_MS) {
  const controller = new AbortController();
  const timeoutHandle = setTimeout(() => controller.abort("timeout"), timeoutMs);

  try {
    const response = await fetch(url, { ...options, signal: controller.signal });
    if (!response.ok) {
      throw new Error(`HTTP ${response.status} voor ${url}`);
    }
    return response;
  } catch (error) {
    if (error?.name === "AbortError") {
      throw new Error(`Timeout na ${timeoutMs}ms voor ${url}`);
    }
    throw error;
  } finally {
    clearTimeout(timeoutHandle);
  }
}

function translateKey(key, language = settings.language) {
  return (
    i18n[language]?.[key] ??
    i18n[FALLBACK_LANG]?.[key] ??
    i18n[DEFAULT_LANG]?.[key] ??
    key
  );
}

const t = (key) => translateKey(key);
const localWord = (key) =>
  localWordLabels[key]?.[settings.language] ??
  localWordLabels[key]?.[FALLBACK_LANG] ??
  localWordLabels[key]?.[DEFAULT_LANG] ??
  key;

function normalizeFieldKey(key) {
  return (key || "")
    .toString()
    .trim()
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "");
}

function translateVehicleFieldLabel(key) {
  const normalized = normalizeFieldKey(key);
  return (
    vehicleFieldLabels[settings.language]?.[normalized] ||
    vehicleFieldLabels[FALLBACK_LANG]?.[normalized] ||
    vehicleFieldLabels[DEFAULT_LANG]?.[normalized] ||
    key
  );
}

const localeForLanguage = (lang) => localeMap[lang] || localeMap[FALLBACK_LANG] || localeMap[DEFAULT_LANG] || "nl-NL";

function escapeHtml(value) {
  return (value ?? "")
    .toString()
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function parseFlexibleDateParts(rawValue) {
  const value = (rawValue || "").toString().trim().replace(/^"|"$/g, "");
  if (!value || value === "/") return null;

  const toValidParts = (year, month, day) => {
    if (month < 1 || month > 12 || day < 1 || day > 31) return null;
    const check = new Date(Date.UTC(year, month - 1, day));
    if (
      check.getUTCFullYear() !== year ||
      check.getUTCMonth() !== month - 1 ||
      check.getUTCDate() !== day
    ) return null;
    return { year, month, day };
  };

  let match = value.match(/^(\d{4})(\d{2})(\d{2})$/);
  if (match) return toValidParts(Number(match[1]), Number(match[2]), Number(match[3]));

  match = value.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (match) return toValidParts(Number(match[1]), Number(match[2]), Number(match[3]));

  match = value.match(/^(\d{2})[\/.-](\d{2})[\/.-](\d{4})$/);
  if (match) return toValidParts(Number(match[3]), Number(match[2]), Number(match[1]));

  return null;
}

function formatDateForUi(rawValue, options, language = settings.language) {
  const parts = parseFlexibleDateParts(rawValue);
  if (parts) {
    const utcDate = new Date(Date.UTC(parts.year, parts.month - 1, parts.day));
    if (!Number.isNaN(utcDate.getTime())) {
      return new Intl.DateTimeFormat(localeForLanguage(language), { ...options, timeZone: "UTC" }).format(utcDate);
    }
  }

  const parsed = new Date(rawValue);
  if (!Number.isNaN(parsed.getTime())) {
    return new Intl.DateTimeFormat(localeForLanguage(language), options).format(parsed);
  }

  return rawValue;
}

function formatDelayMessage(delayMinutes) {
  const lex =
    delayLexicon[settings.language] ||
    delayLexicon[FALLBACK_LANG] ||
    delayLexicon[DEFAULT_LANG] ||
    { minute: "min", early: "early", late: "delay", onTime: "On time" };
  if (delayMinutes < 0) return `${Math.abs(delayMinutes)} ${lex.minute} ${lex.early}`;
  if (delayMinutes > 0) return `${delayMinutes} ${lex.minute} ${lex.late}`;
  return lex.onTime;
}

function isIosInstallable() {
  const ua = window.navigator.userAgent;
  const isIos = /iPhone|iPad|iPod/.test(ua);
  const isStandalone = window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
  return isIos && !isStandalone;
}

function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_KEY);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    settings = { ...settings, ...parsed };
    settings.colorTheme = normalizeColorTheme(settings.colorTheme);
  } catch (e) {
    console.warn("Settings laden mislukt", e);
  }
}

function saveSettings() {
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
}

function applyTheme(theme) {
  const root = document.documentElement;
  if (theme === "auto") root.removeAttribute("data-theme");
  else root.setAttribute("data-theme", theme);
  updateSystemUiThemeColor();
}

function normalizeColorTheme(colorTheme) {
  const value = (colorTheme || "").toString().toLowerCase();
  return ALLOWED_COLOR_THEMES.includes(value) ? value : "classic";
}

function applyColorTheme(colorTheme) {
  const root = document.documentElement;
  const normalized = normalizeColorTheme(colorTheme);
  root.setAttribute("data-color-theme", normalized);
  updateSystemUiThemeColor();
}

function updateSystemUiThemeColor() {
  const css = getComputedStyle(document.documentElement);
  const nextThemeColor =
    css.getPropertyValue("--bg-gradient-top").trim() ||
    css.getPropertyValue("--bg").trim() ||
    "#f4f7fb";
  themeColorMetaEls.forEach((metaEl) => {
    metaEl.setAttribute("content", nextThemeColor);
  });
}

function applyTranslations() {
  appSubtitleEl.textContent = t("subtitle");
  appContextLineEl.textContent = t("appContextLine");
  installBtn.textContent = t("install");
  favoritesToggleBtn.title = t("favorites");
  favoritesToggleBtn.setAttribute("aria-label", t("favorites"));
  settingsToggleBtn.title = t("settings");
  settingsToggleBtn.setAttribute("aria-label", t("settings"));
  iosInstallHintEl.textContent = t("iosHint");
  searchBtn.title = t("search");
  searchBtn.setAttribute("aria-label", t("search"));
  voertuigInput.placeholder = t("vehiclePlaceholder");
  favoritesTitleEl.textContent = t("favorites");
  settingsTitleEl.textContent = t("settings");
  intervalLabelEl.textContent = t("interval");
  themeLabelEl.textContent = t("theme");
  colorThemeLabelEl.textContent = t("colorTheme");
  languageLabelEl.textContent = t("language");
  intervalOpt10El.textContent = `10 ${t("intervalSeconds")}`;
  intervalOpt15El.textContent = `15 ${t("intervalSeconds")}`;
  intervalOpt30El.textContent = `30 ${t("intervalSeconds")}`;
  themeAutoOptEl.textContent = t("themeAuto");
  themeLightOptEl.textContent = t("themeLight");
  themeDarkOptEl.textContent = t("themeDark");
  colorClassicOptEl.textContent = t("colorClassic");
  colorBlueOptEl.textContent = t("colorBlue");
  colorGreenOptEl.textContent = t("colorGreen");
  colorYellowOptEl.textContent = t("colorYellow");
  colorRedOptEl.textContent = t("colorRed");
  staticCardTitleEl.textContent = t("staticCard");
  realtimeCardTitleEl.textContent = t("realtimeCard");
  disclaimerTitleEl.textContent = t("disclaimerTitle");
  disclaimerTextEl.textContent = t("disclaimerText");
  lastUpdateEl.textContent = `${t("lastUpdate")}: -`;
  lastUpdateEl.hidden = true;
  if (!currentVehicleId) {
    realtimeEl.innerHTML = t("noData");
    vasteDataEl.innerHTML = t("noneSelected");
  }
  updateFeedStatusText();
  updateFavoriteButtonState();
  if (realtimePausedByInactivity && currentVehicleId) {
    realtimeEl.textContent = t("idlePaused");
  }
}

function updateFeedStatusText() {
  if (!feedStatusEl) return;
  if (!feedEndDateValue) {
    feedStatusEl.hidden = true;
    feedStatusEl.textContent = "";
    return;
  }

  const formattedDate = formatDateForUi(feedEndDateValue, {
    day: "numeric",
    month: "long",
    year: "numeric"
  });

  const templateRaw = t("feedCurrentUntil");
  const template = templateRaw === "feedCurrentUntil" ? "Data actueel tot {date}." : templateRaw;
  feedStatusEl.textContent = template.includes("{date}")
    ? template.replace("{date}", formattedDate)
    : `${template} ${formattedDate}`;
  feedStatusEl.hidden = false;
}

async function loadFeedStatus() {
  try {
    const res = await fetchWithTimeout(`${BASE_URL}/feed_info.txt`, { cache: "no-store" });
    const text = await res.text();
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    if (lines.length < 2) throw new Error("feed_info bevat te weinig regels");

    const headers = parseCSVLine(lines[0]);
    const values = parseCSVLine(lines[1]);
    const index = headers.indexOf("feed_end_date");
    if (index < 0) throw new Error("feed_end_date niet gevonden");

    feedEndDateValue = (values[index] || "").trim();
  } catch (e) {
    console.warn("feed_info laden mislukt", e);
    feedEndDateValue = "";
  }

  updateFeedStatusText();
}

function setSettingsPanel(open) {
  if (open) setFavoritesPanel(false);
  settingsOpen = !!open;
  document.body.classList.toggle("settings-open", settingsOpen);
  settingsPanelEl.setAttribute("aria-hidden", String(!settingsOpen));
  settingsPanelEl.toggleAttribute("inert", !settingsOpen);
  settingsToggleBtn.setAttribute("aria-expanded", String(settingsOpen));
  settingsToggleBtn.classList.toggle("active", settingsOpen);
}

function setFavoritesPanel(open) {
  const shouldOpen = !!open;
  if (shouldOpen && settingsOpen) setSettingsPanel(false);
  favoritesPanelOpen = shouldOpen;
  favoritesPanelEl.hidden = !favoritesPanelOpen;
  favoritesToggleBtn.setAttribute("aria-expanded", String(favoritesPanelOpen));
  favoritesToggleBtn.classList.toggle("active", favoritesPanelOpen);
}

function showFunnyModal() {
  if (!funnyModalEl) return;
  funnyModalEl.hidden = false;
  document.body.classList.add("funny-open");
}

function hideFunnyModal() {
  if (!funnyModalEl) return;
  funnyModalEl.hidden = true;
  document.body.classList.remove("funny-open");
}

function loadFavorites() {
  try {
    favorites = JSON.parse(localStorage.getItem(FAVORITES_KEY) || "[]");
    if (!Array.isArray(favorites)) favorites = [];
  } catch (e) {
    favorites = [];
  }
}

function saveFavorites() {
  localStorage.setItem(FAVORITES_KEY, JSON.stringify(favorites));
}

function renderFavorites() {
  favoritesListEl.innerHTML = "";
  if (!favorites.length) {
    const empty = document.createElement("span");
    empty.className = "loading";
    empty.textContent = t("noFavoritesYet");
    favoritesListEl.appendChild(empty);
    return;
  }
  favorites.forEach((id) => {
    const chip = document.createElement("button");
    chip.type = "button";
    chip.className = "chip";
    chip.textContent = id;
    chip.addEventListener("click", () => {
      voertuigInput.value = id;
      setFavoritesPanel(false);
      zoekAlles();
    });
    favoritesListEl.appendChild(chip);
  });
}

function updateFavoriteButtonState() {
  const inlineFavoriteBtn = document.getElementById("favoriteInlineBtn");
  if (!inlineFavoriteBtn) {
    return;
  }

  const id = (inlineFavoriteBtn.dataset.id || currentVehicleId || voertuigInput.value || "").trim();
  if (!id) return;

  const isFav = favorites.includes(id);
  const label = isFav ? t("favoriteRemove") : t("favoriteAdd");
  inlineFavoriteBtn.textContent = isFav ? "\u2605" : "\u2606";
  inlineFavoriteBtn.title = label;
  inlineFavoriteBtn.setAttribute("aria-label", label);
  inlineFavoriteBtn.setAttribute("aria-pressed", String(isFav));
  inlineFavoriteBtn.classList.toggle("is-favorite", isFav);
}

function toggleFavorite(explicitId = "") {
  const id = (explicitId || currentVehicleId || voertuigInput.value || "").trim();
  if (!id) return;
  if (favorites.includes(id)) {
    favorites = favorites.filter((x) => x !== id);
  } else {
    favorites.unshift(id);
    favorites = [...new Set(favorites)].slice(0, 20);
  }
  saveFavorites();
  renderFavorites();
  updateFavoriteButtonState();
}

function restartRealtimeRefresh() {
  if (refresh) clearInterval(refresh);
  if (!currentVehicleId || realtimePausedByInactivity) return;
  refresh = setInterval(() => updateRealtime(currentVehicleId), updateIntervalMs);
}

function markUserInteraction(event) {
  lastUserInteractionAt = Date.now();
  if (!realtimePausedByInactivity || !currentVehicleId) return;
  const eventTarget = event?.target;
  const isSearchFieldKeyInteraction =
    event?.type === "keydown" &&
    eventTarget instanceof Element &&
    eventTarget === voertuigInput;
  realtimePausedByInactivity = false;
  restartRealtimeRefresh();
  if (!isSearchFieldKeyInteraction) {
    updateRealtime(currentVehicleId);
  }
}

function pauseRealtimeForInactivity() {
  if (!currentVehicleId || realtimePausedByInactivity) return;
  realtimePausedByInactivity = true;
  if (refresh) {
    clearInterval(refresh);
    refresh = null;
  }
  realtimeEl.textContent = t("idlePaused");
}

function initInactivityMonitor() {
  if (inactivityCheckHandle) return;
  inactivityCheckHandle = setInterval(() => {
    if (!currentVehicleId || realtimePausedByInactivity) return;
    const idleMs = Date.now() - lastUserInteractionAt;
    if (idleMs >= INACTIVITY_LIMIT_MS) {
      pauseRealtimeForInactivity();
    }
  }, INACTIVITY_CHECK_MS);

  ["pointerdown", "touchstart", "wheel", "scroll", "mousedown"].forEach((eventName) => {
    document.addEventListener(eventName, markUserInteraction, { passive: true });
  });
  document.addEventListener("keydown", markUserInteraction);
  window.addEventListener("focus", markUserInteraction);
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) markUserInteraction();
  });
}

function initAppPreferences() {
  loadSettings();
  loadFavorites();
  settings.intervalMs = normalizeUpdateIntervalMs(settings.intervalMs);
  updateIntervalMs = settings.intervalMs;
  intervalSelect.value = String(updateIntervalMs);
  themeSelect.value = settings.theme;
  settings.colorTheme = normalizeColorTheme(settings.colorTheme);
  colorThemeSelect.value = settings.colorTheme;
  languageSelect.value = settings.language;
  applyTheme(settings.theme);
  applyColorTheme(settings.colorTheme);
  applyTranslations();
  setSettingsPanel(false);
  setFavoritesPanel(false);
  renderFavorites();
  loadFeedStatus();
  updateFavoriteButtonState();
  resultsWrapEl.classList.remove("show");
  resultsGridEl.classList.remove("show");
  closeBtnEl.style.display = "none";
  mapEl.classList.add("hidden");
  lastUpdateEl.hidden = true;
  lastUpdateEl.textContent = `${t("lastUpdate")}: -`;

  if (isIosInstallable()) {
    iosInstallHintEl.hidden = false;
  }
  initInactivityMonitor();
}

searchBtn.addEventListener("click", zoekAlles);
voertuigInput.addEventListener("input", updateFavoriteButtonState);
favoritesToggleBtn.addEventListener("click", (event) => {
  event.stopPropagation();
  setFavoritesPanel(!favoritesPanelOpen);
});
favoritesPanelEl.addEventListener("click", (event) => {
  event.stopPropagation();
});
document.addEventListener("click", (event) => {
  if (!favoritesPanelOpen) return;
  const target = event.target;
  if (!(target instanceof Element)) {
    setFavoritesPanel(false);
    return;
  }
  if (favoritesPanelEl.contains(target) || favoritesToggleBtn.contains(target)) return;
  setFavoritesPanel(false);
});
vasteDataEl.addEventListener("click", (event) => {
  const target = event.target;
  if (!(target instanceof Element)) return;
  const inlineFavoriteBtn = target.closest("#favoriteInlineBtn");
  if (!inlineFavoriteBtn) return;
  const id = inlineFavoriteBtn.getAttribute("data-id") || "";
  toggleFavorite(id);
});
intervalSelect.addEventListener("change", () => {
  settings.intervalMs = normalizeUpdateIntervalMs(intervalSelect.value);
  intervalSelect.value = String(settings.intervalMs);
  updateIntervalMs = settings.intervalMs;
  saveSettings();
  restartRealtimeRefresh();
});
themeSelect.addEventListener("change", () => {
  settings.theme = themeSelect.value;
  saveSettings();
  applyTheme(settings.theme);
});
colorThemeSelect.addEventListener("change", () => {
  settings.colorTheme = normalizeColorTheme(colorThemeSelect.value);
  colorThemeSelect.value = settings.colorTheme;
  saveSettings();
  applyColorTheme(settings.colorTheme);
});
languageSelect.addEventListener("change", () => {
  settings.language = languageSelect.value;
  saveSettings();
  applyTranslations();
  renderFavorites();
});
funnyModalCloseBtn?.addEventListener("click", hideFunnyModal);
funnyModalEl?.addEventListener("click", (event) => {
  if (event.target === funnyModalEl) hideFunnyModal();
});
settingsToggleBtn.addEventListener("click", () => setSettingsPanel(!settingsOpen));
settingsCloseBtn.addEventListener("click", () => setSettingsPanel(false));
settingsBackdropEl.addEventListener("click", () => setSettingsPanel(false));
document.addEventListener("keydown", (event) => {
  if (event.key === "Escape" && !funnyModalEl?.hidden) {
    hideFunnyModal();
    return;
  }
  if (event.key === "Escape" && favoritesPanelOpen) {
    setFavoritesPanel(false);
    return;
  }
  if (event.key === "Escape" && settingsOpen) {
    setSettingsPanel(false);
  }
});

// Helper: CSV parser that respects quoted fields
function parseCSVLine(line){
  const fields = [];
  let cur = "";
  let inQuotes = false;
  for(let i=0;i<line.length;i++){
    const ch = line[i];
    if(ch === '"'){
      if(inQuotes && line[i+1] === '"') { cur += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if(ch === ',' && !inQuotes){
      fields.push(cur);
      cur = "";
    } else { cur += ch; }
  }
  fields.push(cur);
  return fields.map(f => f.trim().replace(/^"|"$/g, ''));
}

// Helper: normalize ids/strings for matching
const normalize = s => (s||"").toString().replace(/"/g, "").trim();
const cleanText = (value) => {
  const normalized = normalize(value);
  return normalized === "/" ? "" : normalized;
};
function pickFirstText(...values) {
  for (const value of values) {
    const cleaned = cleanText(value);
    if (cleaned) return cleaned;
  }
  return "";
}
function getRouteKey(routeId) {
  const normalized = cleanText(routeId);
  if (!normalized) return "";
  return cleanText(normalized.split("_")[0]);
}
function getRouteKeyFromTripId(tripId) {
  const normalized = cleanText(tripId);
  if (!normalized) return "";
  return cleanText(normalized.split("_")[0]);
}
function findTripDataByTripId(tripId) {
  const normalizedTripId = cleanText(tripId);
  if (!normalizedTripId) return null;
  const exact = tripsById.get(normalizedTripId);
  if (exact) return exact;

  return trips.find((trip) => {
    const currentTripId = normalize(trip.trip_id);
    return currentTripId && (
      currentTripId.endsWith(normalizedTripId) ||
      normalizedTripId.endsWith(currentTripId) ||
      currentTripId.includes(normalizedTripId) ||
      normalizedTripId.includes(currentTripId)
    );
  }) || null;
}
function findRouteDataByRouteId(routeId, tripId = "") {
  const normalizedRouteId = cleanText(routeId);
  if (normalizedRouteId) {
    const exact = routesById.get(normalizedRouteId);
    if (exact) return exact;

    const fuzzy = routes.find((route) => {
      const currentRouteId = normalize(route.route_id);
      return currentRouteId && (
        currentRouteId === normalizedRouteId ||
        currentRouteId.includes(normalizedRouteId) ||
        normalizedRouteId.includes(currentRouteId)
      );
    });
    if (fuzzy) return fuzzy;
  }

  const routeKey = getRouteKey(normalizedRouteId) || getRouteKeyFromTripId(tripId);
  if (routeKey && routesByKey.has(routeKey)) return routesByKey.get(routeKey);
  return null;
}
const normalizeLookup = s => normalize(s).toLowerCase();
const normalizePlateLookup = s => normalizeLookup(s).replace(/[^a-z0-9]/g, "");

function getVehicleField(vehicle, fieldKey) {
  if (!vehicle || !fieldKey) return "";
  const value = vehicle[fieldKey];
  return value == null ? "" : value.toString().trim();
}

function splitLegacyValues(rawValue, splitOnSpaces = false) {
  const value = normalize(rawValue);
  if (!value || value === "/") return [];
  const pattern = splitOnSpaces ? /[,;| ]+/ : /[,;|]+/;
  return value.split(pattern).map((part) => part.trim()).filter((part) => part && part !== "/");
}

function resolveVehicleSearch(query) {
  const normalizedQuery = normalizeLookup(query);
  const normalizedPlateQuery = normalizePlateLookup(query);
  if (!normalizedQuery && !normalizedPlateQuery) {
    return { bus: null, vehicleId: "" };
  }

  const bus = voertuigen.find((vehicle) => {
    const vehicleNumber = normalizeLookup(vehicle.Voertuignummer);
    if (vehicleNumber && vehicleNumber === normalizedQuery) return true;

    const plate = normalizePlateLookup(getVehicleField(vehicle, vehiclePlateFieldKey));
    if (normalizedPlateQuery && plate && plate === normalizedPlateQuery) return true;

    const oldVehicleNumbers = splitLegacyValues(getVehicleField(vehicle, oldVehicleNumbersFieldKey), true);
    if (oldVehicleNumbers.some((value) => normalizeLookup(value) === normalizedQuery)) return true;

    const oldPlates = splitLegacyValues(getVehicleField(vehicle, oldLicensePlatesFieldKey), false);
    if (normalizedPlateQuery && oldPlates.some((value) => normalizePlateLookup(value) === normalizedPlateQuery)) return true;

    return false;
  });

  return {
    bus: bus || null,
    vehicleId: bus ? normalize(bus.Voertuignummer) : ""
  };
}

function matchesSuggestionQuery(vehicle, normalizedQuery, normalizedPlateQuery) {
  const vehicleNumber = normalizeLookup(vehicle.Voertuignummer);
  if (normalizedQuery && vehicleNumber.startsWith(normalizedQuery)) return true;

  const plate = normalizePlateLookup(getVehicleField(vehicle, vehiclePlateFieldKey));
  if (normalizedPlateQuery && plate && plate.startsWith(normalizedPlateQuery)) return true;

  const oldVehicleNumbers = splitLegacyValues(getVehicleField(vehicle, oldVehicleNumbersFieldKey), true);
  if (normalizedQuery && oldVehicleNumbers.some((value) => normalizeLookup(value).startsWith(normalizedQuery))) return true;

  const oldPlates = splitLegacyValues(getVehicleField(vehicle, oldLicensePlatesFieldKey), false);
  if (normalizedPlateQuery && oldPlates.some((value) => normalizePlateLookup(value).startsWith(normalizedPlateQuery))) return true;

  return false;
}

function buildSuggestionLabel(vehicle) {
  const vehicleNumber = normalize(vehicle.Voertuignummer);
  const vehicleType = normalize(vehicle.Type);
  const plate = normalize(getVehicleField(vehicle, vehiclePlateFieldKey));
  const parts = [`${vehicleNumber}`];
  if (vehicleType && vehicleType !== "/") parts.push(vehicleType);
  if (plate && plate !== "/") parts.push(plate);
  return parts.join(" - ");
}

// Custom bus pin as DivIcon so we can rotate the image based on bearing
const busIcon = L.divIcon({
  className: 'bus-div-icon',
  html: `<img src="media/navicon.png" style="width:36px;height:36px;transform:rotate(0deg);display:block;transform-origin:18px 28px;transition: transform 0.25s linear;"/>`,
  iconSize: [36,36],
  iconAnchor: [18,36]
});

async function laadVoertuigen() {
  const res = await fetchWithTimeout(`${BASE_URL}/vehicles.txt`, { cache: "no-store" });
  const text = await res.text();
  const regels = text.trim().split(/\r?\n/);
  const headers = regels[0].split(";");
  const headerByNormalizedName = new Map();
  headers.forEach((header) => {
    const trimmed = header.trim();
    headerByNormalizedName.set(normalizeFieldKey(trimmed), trimmed);
  });
  vehiclePlateFieldKey = headerByNormalizedName.get("nummerplaat") || "";
  oldVehicleNumbersFieldKey = headerByNormalizedName.get("oude voertuignummers") || "";
  oldLicensePlatesFieldKey = headerByNormalizedName.get("oude nummerplaten") || "";

  voertuigen = regels.slice(1).map(r => {
    const v = r.split(";");
    const obj = {};
    headers.forEach((h,i)=>obj[h.trim()] = v[i]?.trim() || "/");
    return obj;
  });
}

async function laadTrips() {
  const res = await fetchWithTimeout(`${BASE_URL}/trips.txt`, { cache: "no-store" });
  const text = await res.text();
  const regels = text.trim().split(/\r?\n/);
  const headers = parseCSVLine(regels[0]).map(h => h.trim());

  trips = regels.slice(1).map(r => {
    const values = parseCSVLine(r);
    const obj = {};
    headers.forEach((h, i) => obj[h] = values[i] || "/");
    return obj;
  });

  tripsById.clear();
  trips.forEach((trip) => {
    const tripId = normalize(trip.trip_id);
    if (tripId) tripsById.set(tripId, trip);
  });
}

async function laadRoutes() {
  const res = await fetchWithTimeout(`${BASE_URL}/routes.txt`, { cache: "no-store" });
  const text = await res.text();
  const regels = text.trim().split(/\r?\n/);
  const headers = parseCSVLine(regels[0]).map(h => h.trim());

  routes = regels.slice(1).map(r => {
    const values = parseCSVLine(r);
    const obj = {};
    headers.forEach((h, i) => obj[h] = values[i] || "/");
    return obj;
  });

  routesById.clear();
  routesByKey.clear();
  routes.forEach((route) => {
    const routeId = normalize(route.route_id);
    if (routeId) routesById.set(routeId, route);
    const routeKey = getRouteKey(routeId);
    if (routeKey && !routesByKey.has(routeKey)) routesByKey.set(routeKey, route);
  });
}

async function laadStops() {
  const res = await fetchWithTimeout(`${BASE_URL}/stops.txt`, { cache: "no-store" });
  const text = await res.text();
  const regels = text.trim().split(/\r?\n/);
  const headers = parseCSVLine(regels[0]).map(h => h.trim());

  stops = regels.slice(1).map(r => {
    const values = parseCSVLine(r);
    const obj = {};
    headers.forEach((h, i) => obj[h] = values[i] || "/");
    return obj;
  });

  stopsById.clear();
  stops.forEach((stop) => {
    const stopId = normalize(stop.stop_id);
    const stopCode = normalize(stop.stop_code);
    if (stopId) stopsById.set(stopId, stop);
    if (stopCode) stopsById.set(stopCode, stop);
  });
}

initAppPreferences();
void laadVoertuigen().catch((e) => console.warn("Warm-up voertuigen mislukt", e));
void laadTrips().catch((e) => console.warn("Warm-up trips mislukt", e));
void laadRoutes().catch((e) => console.warn("Warm-up routes mislukt", e));
void laadStops().catch((e) => console.warn("Warm-up haltes mislukt", e));

function toonSuggesties() {
  const query = voertuigInput.value.trim();
  const normalizedQuery = normalizeLookup(query);
  const normalizedPlateQuery = normalizePlateLookup(query);
  suggestieLijst.innerHTML = "";
  if(!normalizedQuery && !normalizedPlateQuery) return;

  voertuigen.filter(v => matchesSuggestionQuery(v, normalizedQuery, normalizedPlateQuery))
    .slice(0,8)
    .forEach(v=>{
      const li=document.createElement("li");
      li.textContent = buildSuggestionLabel(v);
      li.onclick=()=>{
        voertuigInput.value = normalize(v.Voertuignummer);
        suggestieLijst.innerHTML="";
        voertuigInput.blur(); // Focus weghalen zodat geen enter meer nodig is
        zoekAlles();
      };
      suggestieLijst.appendChild(li);
    });
}

async function zoekAlles() {
  markUserInteraction();
  const query = voertuigInput.value.trim();
  if(!query) return;
  setFavoritesPanel(false);
  if (query.toLowerCase() === "best") {
    suggestieLijst.innerHTML = "";
    showFunnyModal();
    return;
  }
  if (query.toLowerCase() === "bus beih") {
    suggestieLijst.innerHTML = "";
    window.open("https://salajev.github.io/bus.be-fcl/index.html", "_blank", "noopener,noreferrer");
    return;
  }
  if (voertuigen.length === 0) await laadVoertuigen();
  const resolved = resolveVehicleSearch(query);
  const activeVehicleId = resolved.vehicleId || normalize(query);
  const bus = resolved.bus;
  currentVehicleId = activeVehicleId;
  realtimePausedByInactivity = false;
  if (resolved.vehicleId && activeVehicleId !== query) {
    voertuigInput.value = activeVehicleId;
  }
  updateFavoriteButtonState();

  suggestieLijst.innerHTML = "";
  resultsWrapEl.classList.add("show");
  resultsGridEl.classList.add("show");
  closeBtnEl.style.display = "block";

  toonVasteData(activeVehicleId);
  lastUpdateEl.hidden = true;
  lastUpdateEl.textContent = `${t("lastUpdate")}: -`;

  if (isOutOfService(bus)) {
    realtimeEl.innerHTML = t("outOfServiceNoRealtime");
    mapEl.classList.add("hidden");
    routeTrail = [];
    if (trailLine && map) {
      map.removeLayer(trailLine);
      trailLine = null;
    }
    if (marker && map) {
      map.removeLayer(marker);
      marker = null;
    }
    lastUpdateEl.textContent = `${t("lastUpdate")}: -`;
    lastUpdateEl.hidden = true;
    if(refresh) {
      clearInterval(refresh);
      refresh = null;
    }
    return;
  }

  realtimeEl.innerHTML = `<span class='spinner'></span><span class='loading'>${t("loading")}</span>`;
  routeTrail = [];
  if (trailLine && map) {
    map.removeLayer(trailLine);
    trailLine = null;
  }

  updateRealtime(activeVehicleId);
  restartRealtimeRefresh();
}

function terug() {
  resultsGridEl.classList.remove("show");
  resultsWrapEl.classList.remove("show");
  closeBtnEl.style.display = "none";
  realtimeEl.innerHTML = t("noData");
  vasteDataEl.innerHTML = t("noneSelected");
  voertuigInput.value = "";
  currentVehicleId = "";
  realtimePausedByInactivity = false;
  routeTrail = [];
  if(refresh) {
    clearInterval(refresh);
    refresh = null;
  }
  if (trailLine && map) {
    map.removeLayer(trailLine);
    trailLine = null;
  }
  lastUpdateEl.textContent = `${t("lastUpdate")}: -`;
  lastUpdateEl.hidden = true;
  mapEl.classList.add("hidden");
  if(marker){ map.removeLayer(marker); marker=null; }
  updateFavoriteButtonState();
}

function findBusById(id) {
  return resolveVehicleSearch(id).bus;
}

function isOutOfService(bus) {
  if (!bus) return false;
  const outKeys = Object.keys(bus).filter(k => k.toLowerCase().includes("uit dienst"));
  for (const k of outKeys) {
    const val = (bus[k] || "").toString().trim();
    if (val && val !== "/") return true;
  }
  return false;
}

function toonVasteData(id){
  const bus = findBusById(id);

  if(!bus){
    vasteDataEl.innerHTML=t("noFixed");
    return;
  }

  const favoriteLabel = favorites.includes(id) ? t("favoriteRemove") : t("favoriteAdd");
  const favoriteStateSymbol = favorites.includes(id) ? "\u2605" : "\u2606";
  const safeFavoriteId = id.replace(/"/g, "&quot;");
  const favoriteClass = favorites.includes(id) ? "vehicle-favorite-btn is-favorite" : "vehicle-favorite-btn";

  let html=`<div class="vehicle-title-row"><p class="voertuignummer-display">${bus.Voertuignummer}</p><button id="favoriteInlineBtn" class="${favoriteClass}" type="button" title="${favoriteLabel}" aria-label="${favoriteLabel}" aria-pressed="${favorites.includes(id)}" data-id="${safeFavoriteId}">${favoriteStateSymbol}</button></div>`;
  if(bus.Type) html += `<p class="vehicle-type">${bus.Type}</p>`;
  html+="<table>";
  for(const [k,v] of Object.entries(bus)){
    if(k==="Vervoersmaatschappij"||k==="Voertuignummer"||k==="Type") continue;

    let waarde = v;
    const key = k.toLowerCase();
    const normalizedKey = normalizeFieldKey(k);

    if(key.includes("datum in dienst") && v!=="/") {
      waarde = formatDateForUi(v, { year:'numeric', month:'long', day:'numeric' });
    } else if(key.includes("uit dienst")) {
      if(v==="/") waarde = t("notOutOfService");
      else waarde = formatDateForUi(v, { year:'numeric', month:'long', day:'numeric' });
    } else if(key.includes("datum") && v!=="/") {
      waarde = formatDateForUi(v, { weekday:'long', year:'numeric', month:'long', day:'numeric' });
    } else {
      if(v==="/") continue;
    }
    let waardeMarkup = escapeHtml(waarde);
    if (normalizedKey === "hansea nummer") {
      waardeMarkup = `
        <span class="hansea-number-display">
          <img src="media/hansea.png" alt="Hansea" class="hansea-logo" loading="lazy" decoding="async">
          <span>${escapeHtml(waarde)}</span>
        </span>
      `;
    }
    html+=`<tr><th>${translateVehicleFieldLabel(k)}</th><td>${waardeMarkup}</td></tr>`;
  }
  html+="</table>";

  const igUrl = 'https://www.instagram.com/explore/search/keyword/?q=' + encodeURIComponent('#dl' + id);
  const links = [
    `<a class="btn btn--instagram" href="${igUrl}" target="_blank" rel="noopener">${localWord("instagramSearch")}</a>`
  ];
  const idNum = Number(id);
  if (Number.isInteger(idNum) && idNum >= 4404 && idNum <= 4459) {
    links.push(`<a class="btn btn--story" href="https://sites.google.com/view/delijn-busspotter/dampkap" target="_blank" rel="noopener">${t("story44xx")}</a>`);
  }
  html += `<div class="ig-btn-wrap">${links.join("")}</div>`;
  vasteDataEl.innerHTML=html;
  updateFavoriteButtonState();
}

function initMap(lat,lon){
  if(!map){
    map=L.map("map").setView([lat,lon],14);

    // Cleaner base map suitable for transit (CartoDB Positron)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors &amp; <a href="https://carto.com/">CARTO</a>'
    }).addTo(map);

    // Optional transport overlay (rail/lines) - may enhance transit visualization
    const transportOverlay = L.tileLayer('https://a.tile.openrailwaymap.org/standard/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenRailwayMap'
    });
    transportOverlay.addTo(map);
  }
}

function getEntityVehiclePayload(entity) {
  return entity?.vehicle || entity?.vehiclePosition || entity?.vehicle_position || null;
}

function getEntityTripUpdatePayload(entity) {
  return entity?.tripUpdate || entity?.trip_update || null;
}

function extractTripDescriptor(...sources) {
  for (const source of sources) {
    if (!source || typeof source !== "object") continue;
    const candidates = [
      source.trip,
      source.tripDescriptor,
      source.trip_descriptor,
      source.tripUpdate,
      source.trip_update,
      source
    ];
    for (const candidate of candidates) {
      if (!candidate || typeof candidate !== "object") continue;
      const tripId = cleanText(candidate.tripId || candidate.trip_id || candidate.tripID || "");
      const routeId = cleanText(candidate.routeId || candidate.route_id || candidate.lineId || candidate.line_id || "");
      const routeShortName = cleanText(candidate.routeShortName || candidate.route_short_name || candidate.lineShortName || candidate.line_short_name || "");
      const headsign = cleanText(candidate.tripHeadsign || candidate.trip_headsign || candidate.headsign || candidate.destination || "");
      if (tripId || routeId || routeShortName || headsign) {
        return { tripId, routeId, routeShortName, headsign };
      }
    }
  }
  return { tripId: "", routeId: "", routeShortName: "", headsign: "" };
}

function getVehicleDescriptorId(vehicleDescriptor) {
  return cleanText(
    vehicleDescriptor?.id ||
    vehicleDescriptor?.vehicleId ||
    vehicleDescriptor?.vehicle_id ||
    vehicleDescriptor?.label ||
    ""
  );
}

function getVehicleIdFromTripUpdate(tripUpdate) {
  if (!tripUpdate || typeof tripUpdate !== "object") return "";
  const descriptor =
    tripUpdate?.vehicle ||
    tripUpdate?.vehicleDescriptor ||
    tripUpdate?.vehicle_descriptor;
  return getVehicleDescriptorId(descriptor);
}

function getTripUpdateForVehicle(entities, vehicleId, tripId = "") {
  const normalizedVehicleId = cleanText(vehicleId);
  const normalizedTripId = cleanText(tripId);
  if (!Array.isArray(entities)) return null;

  const byVehicleId = entities.find((entity) => {
    const tripUpdate = getEntityTripUpdatePayload(entity);
    const descriptor =
      tripUpdate?.vehicle ||
      tripUpdate?.vehicleDescriptor ||
      tripUpdate?.vehicle_descriptor;
    return getVehicleDescriptorId(descriptor) === normalizedVehicleId;
  });
  if (byVehicleId) return getEntityTripUpdatePayload(byVehicleId);

  if (normalizedTripId) {
    const byTripId = entities.find((entity) => {
      const descriptor = extractTripDescriptor(getEntityTripUpdatePayload(entity));
      return descriptor.tripId === normalizedTripId;
    });
    if (byTripId) return getEntityTripUpdatePayload(byTripId);
  }

  return null;
}

function getTripUpdateForEntityId(entities, entityId) {
  const normalizedEntityId = cleanText(entityId);
  if (!normalizedEntityId || !Array.isArray(entities)) return null;
  const match = entities.find((entity) => {
    const currentEntityId = cleanText(entity?.id || entity?.entityId || entity?.entity_id || "");
    return currentEntityId === normalizedEntityId && !!getEntityTripUpdatePayload(entity);
  });
  return match ? getEntityTripUpdatePayload(match) : null;
}

function getDelaySecondsFromTripUpdate(tripUpdate) {
  const updates = tripUpdate?.stopTimeUpdate || tripUpdate?.stop_time_update;
  if (!Array.isArray(updates) || updates.length === 0) return null;
  const now = Math.floor(Date.now() / 1000);
  let best = null;

  for (const stop of updates) {
    const candidates = [stop.departure, stop.arrival];
    for (const c of candidates) {
      if (!c) continue;
      const delay = typeof c.delay === "number" ? c.delay : (typeof c.delay_seconds === "number" ? c.delay_seconds : null);
      if (typeof delay !== "number") continue;
      const eventTime = typeof c.time === "number" ? c.time : (typeof c.timestamp === "number" ? c.timestamp : null);
      const score = typeof eventTime === "number" ? Math.abs(eventTime - now) : Number.MAX_SAFE_INTEGER;
      if (!best || score < best.score) {
        best = { delay, score };
      }
    }
  }
  return best ? best.delay : null;
}

function getCurrentStopIdFromTripUpdate(tripUpdate) {
  const updates = tripUpdate?.stopTimeUpdate || tripUpdate?.stop_time_update;
  if (!Array.isArray(updates) || updates.length === 0) return "";

  const now = Math.floor(Date.now() / 1000);
  let best = null;

  updates.forEach((stop, index) => {
    const stopId = cleanText(stop?.stopId || stop?.stop_id || stop?.assignedStopId || stop?.assigned_stop_id || "");
    if (!stopId) return;

    const candidates = [stop.departure?.time, stop.arrival?.time, stop.departure?.timestamp, stop.arrival?.timestamp]
      .filter((t) => typeof t === "number");
    const score = candidates.length
      ? Math.min(...candidates.map((t) => Math.abs(t - now)))
      : Number.MAX_SAFE_INTEGER;

    if (!best || score < best.score || (score === best.score && index < best.index)) {
      best = { stopId, score, index };
    }
  });

  return best?.stopId || "";
}

function getStopByStopId(stopId) {
  const normalized = normalize(stopId);
  if (!normalized) return null;
  return stopsById.get(normalized) || null;
}

async function updateRealtime(id){
  try{
    const res = await fetchWithTimeout(API_URL);
    const data = await res.json();
    const entities = Array.isArray(data.entity) ? data.entity : [];
    const normalizedRequestedId = cleanText(id);
    const gpsEntity = [...entities].reverse().find((entity) => {
      const vehiclePayload = getEntityVehiclePayload(entity);
      if (!vehiclePayload?.position) return false;
      const descriptor =
        vehiclePayload?.vehicle ||
        vehiclePayload?.vehicleDescriptor ||
        vehiclePayload?.vehicle_descriptor;
      const descriptorId = getVehicleDescriptorId(descriptor);
      return descriptorId === normalizedRequestedId;
    });
    const gps = gpsEntity ? { vehicle: getEntityVehiclePayload(gpsEntity) } : null;

    if(!gps){
      realtimeEl.innerHTML=t("noData");
      mapEl.classList.add("hidden");
      lastUpdateEl.textContent = `${t("lastUpdate")}: -`;
      lastUpdateEl.hidden = true;
      return;
    }

    const v=gps.vehicle;
    const vehicleDescriptor = extractTripDescriptor(v);
    let tripUpdate = getTripUpdateForVehicle(entities, id, vehicleDescriptor.tripId);
    if (!tripUpdate) {
      const gpsEntityId = cleanText(gpsEntity?.id || gpsEntity?.entityId || gpsEntity?.entity_id || "");
      tripUpdate = getTripUpdateForEntityId(entities, gpsEntityId);
    }
    const tripUpdateDescriptor = extractTripDescriptor(tripUpdate);
    const descriptor = {
      tripId: vehicleDescriptor.tripId || tripUpdateDescriptor.tripId,
      routeId: vehicleDescriptor.routeId || tripUpdateDescriptor.routeId,
      routeShortName: vehicleDescriptor.routeShortName || tripUpdateDescriptor.routeShortName,
      headsign: vehicleDescriptor.headsign || tripUpdateDescriptor.headsign
    };
    const tripid = descriptor.tripId;

    // Zorg dat trips/routes geladen zijn
    if(trips.length===0) await laadTrips();
    if(routes.length===0) await laadRoutes();
    if(stopsById.size===0) await laadStops();
    const tripUpdateVehicleId = getVehicleIdFromTripUpdate(tripUpdate);
    const sameVehicleTripUpdate = !!tripUpdate && tripUpdateVehicleId === normalizedRequestedId;
    const sameTripTripUpdate = !!tripUpdate && !!vehicleDescriptor.tripId && !!tripUpdateDescriptor.tripId && vehicleDescriptor.tripId === tripUpdateDescriptor.tripId;
    const canUseTripUpdateStop = sameVehicleTripUpdate || sameTripTripUpdate;
    const currentStopId = canUseTripUpdateStop ? getCurrentStopIdFromTripUpdate(tripUpdate) : "";
    const currentStop = getStopByStopId(currentStopId);
    const currentStopName = (currentStop?.stop_name || currentStopId || "-").toString().trim() || "-";
    const currentStopUrlRaw = (currentStop?.stop_url || "").toString().trim();
    const currentStopUrl = /^https?:\/\//i.test(currentStopUrlRaw) ? currentStopUrlRaw : "";

    // Robuuste matching: normaliseer en probeer exact / endsWith / includes
    const nTripId = cleanText(tripid);
    const tripData = findTripDataByTripId(nTripId);
    
    const vehicleRouteId = cleanText(descriptor.routeId);
    const routeId = pickFirstText(tripData?.route_id, vehicleRouteId, getRouteKeyFromTripId(nTripId));
    const routeData = findRouteDataByRouteId(routeId, nTripId);

    const routeShortRaw = pickFirstText(
      routeData?.route_short_name,
      descriptor.routeShortName,
      routeId
    );
    const routeShort = routeShortRaw || "?";
    const tripShort = tripData ? pickFirstText(tripData.trip_short_name) : "";
    const destinationText = tripShort || "-";
    if (routeShort === "?" || destinationText === "-") {
      console.warn("[busbibliotheek] lijn/bestemming niet gevonden", {
        vehicleId: normalizedRequestedId,
        gpsEntityId: cleanText(gpsEntity?.id || ""),
        currentStopId,
        canUseTripUpdateStop,
        tripUpdateVehicleId,
        vehicleDescriptor,
        tripUpdateDescriptor,
        tripId: nTripId,
        routeId,
        hasTripData: !!tripData,
        hasRouteData: !!routeData,
        hasTripUpdate: !!tripUpdate
      });
    }
    const routeUrlRaw = (routeData?.route_url || "").toString().trim();
    const routeUrl = /^https?:\/\//i.test(routeUrlRaw) ? routeUrlRaw : "";
    const routeColorRaw = (routeData?.route_color || "").replace(/[^0-9a-fA-F]/g, "").slice(0, 6);
    const routeTextColorRaw = (routeData?.route_text_color || "").replace(/[^0-9a-fA-F]/g, "").slice(0, 6);
    const routeColor = routeColorRaw.length === 6 ? `#${routeColorRaw}` : "#2563eb";
    const routeTextColor = routeTextColorRaw.length === 6 ? `#${routeTextColorRaw}` : "#ffffff";

    // Delay from trip updates is authoritative; fallback to vehicle payload
    let delaySeconds = canUseTripUpdateStop ? getDelaySecondsFromTripUpdate(tripUpdate) : null;
    if (typeof delaySeconds !== "number" && typeof gps.vehicle.trip?.delay === "number") {
      delaySeconds = gps.vehicle.trip.delay;
    }
    if (typeof delaySeconds !== "number" && typeof v.stopStatus?.delay === "number") {
      delaySeconds = v.stopStatus.delay;
    }
    if (typeof delaySeconds !== "number") delaySeconds = 0;
    delayMinutes = delaySeconds < 0
      ? -Math.round(Math.abs(delaySeconds) / 60)
      : Math.round(delaySeconds / 60);
    
    const msgDelay = formatDelayMessage(delayMinutes);
    const delayClass = delayMinutes < 0 ? "delay-early" : delayMinutes > 0 ? "delay-late" : "delay-ontime";
    const routeRowInner = `
      <span class="line-badge" style="background:${routeColor};color:${routeTextColor};">${escapeHtml(routeShort)}</span>
      <span class="destination-text">${escapeHtml(destinationText)}</span>
    `;
    const routeRowMarkup = routeUrl
      ? `<a class="route-destination-row route-link" href="${escapeHtml(routeUrl)}" target="_blank" rel="noopener noreferrer">${routeRowInner}</a>`
      : `<div class="route-destination-row">${routeRowInner}</div>`;
    const currentStopValueMarkup = currentStopUrl
      ? `<a class="current-stop-link" href="${escapeHtml(currentStopUrl)}" target="_blank" rel="noopener noreferrer">${escapeHtml(currentStopName)}</a>`
      : `<span class="current-stop-link">${escapeHtml(currentStopName)}</span>`;

    realtimeEl.innerHTML=`
      ${routeRowMarkup}
      <div class="current-stop-row">
        <span class="current-stop-label">${escapeHtml(t("currentStop"))}:</span>
        ${currentStopValueMarkup}
      </div>
      <span class="delay-status ${delayClass}">${escapeHtml(msgDelay)}</span>
    `;
    mapEl.classList.remove("hidden");
    lastUpdateEl.textContent = `${t("lastUpdate")}: ${new Date().toLocaleTimeString(localeForLanguage(settings.language))}`;
    lastUpdateEl.hidden = false;

    initMap(v.position.latitude,v.position.longitude);
    routeTrail.push([v.position.latitude, v.position.longitude]);
    if (routeTrail.length > 35) routeTrail.shift();
    if (routeTrail.length >= 2) {
      if (!trailLine) {
        trailLine = L.polyline(routeTrail, { color: "#ef4444", weight: 4, opacity: 0.75 }).addTo(map);
      } else {
        trailLine.setLatLngs(routeTrail);
      }
    }

    map.setView([v.position.latitude,v.position.longitude],15);

    const bearing = v.position.bearing || 0;

    if(marker) {
      marker.setLatLng([v.position.latitude,v.position.longitude]);
      // update rotation of img inside divIcon
      const el = marker.getElement && marker.getElement();
      if(el){
        const img = el.querySelector('img');
        if(img) img.style.transform = `rotate(${bearing}deg)`;
      }
    } else {
      marker = L.marker([v.position.latitude,v.position.longitude], { icon: busIcon })
        .addTo(map);
      // set initial rotation
      const el = marker.getElement && marker.getElement();
      if(el){
        const img = el.querySelector('img');
        if(img) img.style.transform = `rotate(${bearing}deg)`;
      }
    }

  }catch(e){
    console.error(e);
    realtimeEl.innerHTML = t("realtimeError");
    mapEl.classList.add("hidden");
    lastUpdateEl.textContent = `${t("lastUpdate")}: -`;
    lastUpdateEl.hidden = true;
  }
}
</script>

<!-- Service Worker Registration -->
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js')
    .catch(err => console.error('Service Worker registratie mislukt:', err));
}

if (prefersDarkScheme?.addEventListener) {
  prefersDarkScheme.addEventListener("change", () => {
    if (settings.theme === "auto") updateSystemUiThemeColor();
  });
} else if (prefersDarkScheme?.addListener) {
  prefersDarkScheme.addListener(() => {
    if (settings.theme === "auto") updateSystemUiThemeColor();
  });
}
</script>
</body>
</html>

